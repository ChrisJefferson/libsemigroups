<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libsemigroups: libsemigroups::Semigroup Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsemigroups
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibsemigroups.html">libsemigroups</a></li><li class="navelem"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classlibsemigroups_1_1_semigroup-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libsemigroups::Semigroup Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for semigroups generated by instances of <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>.  
 <a href="classlibsemigroups_1_1_semigroup.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="semigroups_8h_source.html">semigroups.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afeab9f00f93f7f506487eb784244e20e"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a></td></tr>
<tr class="memdesc:afeab9f00f93f7f506487eb784244e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for the position of an element in an instance of <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a>.  <a href="#afeab9f00f93f7f506487eb784244e20e">More...</a><br /></td></tr>
<tr class="separator:afeab9f00f93f7f506487eb784244e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae09471d9df3b44fbaf1b5d08c2576f38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae09471d9df3b44fbaf1b5d08c2576f38">Semigroup</a> (std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const *<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159">gens</a>)</td></tr>
<tr class="memdesc:ae09471d9df3b44fbaf1b5d08c2576f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from generators.  <a href="#ae09471d9df3b44fbaf1b5d08c2576f38">More...</a><br /></td></tr>
<tr class="separator:ae09471d9df3b44fbaf1b5d08c2576f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64e868428997b22a873954262562fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#adc64e868428997b22a873954262562fc">Semigroup</a> (std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159">gens</a>)</td></tr>
<tr class="memdesc:adc64e868428997b22a873954262562fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from generators.  <a href="#adc64e868428997b22a873954262562fc">More...</a><br /></td></tr>
<tr class="separator:adc64e868428997b22a873954262562fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c7dfcba762a3ac9f0f0a58c268f741"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aa0c7dfcba762a3ac9f0f0a58c268f741">Semigroup</a> (const <a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> &amp;copy)</td></tr>
<tr class="memdesc:aa0c7dfcba762a3ac9f0f0a58c268f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#aa0c7dfcba762a3ac9f0f0a58c268f741">More...</a><br /></td></tr>
<tr class="separator:aa0c7dfcba762a3ac9f0f0a58c268f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad56c6cad6baba69ae4c3e1c133b428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a1ad56c6cad6baba69ae4c3e1c133b428">~Semigroup</a> ()</td></tr>
<tr class="memdesc:a1ad56c6cad6baba69ae4c3e1c133b428"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default destructor.  <a href="#a1ad56c6cad6baba69ae4c3e1c133b428">More...</a><br /></td></tr>
<tr class="separator:a1ad56c6cad6baba69ae4c3e1c133b428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8af8615e4a45aa6e83837f01baa5a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2">add_generators</a> (const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *coll)</td></tr>
<tr class="memdesc:a7a8af8615e4a45aa6e83837f01baa5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the generators <code>coll</code> to the generators of <code>this</code>.  <a href="#a7a8af8615e4a45aa6e83837f01baa5a2">More...</a><br /></td></tr>
<tr class="separator:a7a8af8615e4a45aa6e83837f01baa5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58bf0d461a907ccf7ee6f124c97a7a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad58bf0d461a907ccf7ee6f124c97a7a6">add_generators</a> (std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;coll)</td></tr>
<tr class="memdesc:ad58bf0d461a907ccf7ee6f124c97a7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the generators <code>coll</code> to the generators of <code>this</code>.  <a href="#ad58bf0d461a907ccf7ee6f124c97a7a6">More...</a><br /></td></tr>
<tr class="separator:ad58bf0d461a907ccf7ee6f124c97a7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6215251257f940170f43f4f403d998d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad6215251257f940170f43f4f403d998d">at</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:ad6215251257f940170f43f4f403d998d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code>, or a <code>nullptr</code> if there is no such element.  <a href="#ad6215251257f940170f43f4f403d998d">More...</a><br /></td></tr>
<tr class="separator:ad6215251257f940170f43f4f403d998d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a52a6e228af7de9d4fa627c739df0a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a52a6e228af7de9d4fa627c739df0a0">batch_size</a> () const</td></tr>
<tr class="memdesc:a7a52a6e228af7de9d4fa627c739df0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value of the batch size. This is the minimum number of elements enumerated in any call to <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>.  <a href="#a7a52a6e228af7de9d4fa627c739df0a0">More...</a><br /></td></tr>
<tr class="separator:a7a52a6e228af7de9d4fa627c739df0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6820e18dfb877db3a868463335d8ea65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a6820e18dfb877db3a868463335d8ea65">closure</a> (const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *coll)</td></tr>
<tr class="memdesc:a6820e18dfb877db3a868463335d8ea65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>.  <a href="#a6820e18dfb877db3a868463335d8ea65">More...</a><br /></td></tr>
<tr class="separator:a6820e18dfb877db3a868463335d8ea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726b4e24b52fbbf56b934d785361a842"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a726b4e24b52fbbf56b934d785361a842">closure</a> (std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;coll)</td></tr>
<tr class="memdesc:a726b4e24b52fbbf56b934d785361a842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>.  <a href="#a726b4e24b52fbbf56b934d785361a842">More...</a><br /></td></tr>
<tr class="separator:a726b4e24b52fbbf56b934d785361a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3218fc2409ab38bf5c4360967df70b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aa3218fc2409ab38bf5c4360967df70b2">copy_add_generators</a> (const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *coll) const</td></tr>
<tr class="memdesc:aa3218fc2409ab38bf5c4360967df70b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new semigroup generated by <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">gens()</a></code> and <code>coll</code>.  <a href="#aa3218fc2409ab38bf5c4360967df70b2">More...</a><br /></td></tr>
<tr class="separator:aa3218fc2409ab38bf5c4360967df70b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e06fb2f4c02e76bfe3148ad57a5257f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a0e06fb2f4c02e76bfe3148ad57a5257f">copy_closure</a> (std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const *coll)</td></tr>
<tr class="memdesc:a0e06fb2f4c02e76bfe3148ad57a5257f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new semigroup generated by <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">gens()</a></code> and copies of the non-redundant elements of <code>coll</code>.  <a href="#a0e06fb2f4c02e76bfe3148ad57a5257f">More...</a><br /></td></tr>
<tr class="separator:a0e06fb2f4c02e76bfe3148ad57a5257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27b64c78b82236c611c8b82018d6243"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae27b64c78b82236c611c8b82018d6243">current_max_word_length</a> () const</td></tr>
<tr class="memdesc:ae27b64c78b82236c611c8b82018d6243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum length of a word in the generators so far computed.  <a href="#ae27b64c78b82236c611c8b82018d6243">More...</a><br /></td></tr>
<tr class="separator:ae27b64c78b82236c611c8b82018d6243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9254472e2374d27a915bd533103c8da0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a9254472e2374d27a915bd533103c8da0">current_nrrules</a> () const</td></tr>
<tr class="memdesc:a9254472e2374d27a915bd533103c8da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of relations in the presentation for the semigroup that have been found so far.  <a href="#a9254472e2374d27a915bd533103c8da0">More...</a><br /></td></tr>
<tr class="separator:a9254472e2374d27a915bd533103c8da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63553b44a18e9fb8fe7329e953938f10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a63553b44a18e9fb8fe7329e953938f10">current_position</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x) const</td></tr>
<tr class="memdesc:a63553b44a18e9fb8fe7329e953938f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup.  <a href="#a63553b44a18e9fb8fe7329e953938f10">More...</a><br /></td></tr>
<tr class="separator:a63553b44a18e9fb8fe7329e953938f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1994e708194877086ebd926018ebc46"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad1994e708194877086ebd926018ebc46">current_size</a> () const</td></tr>
<tr class="memdesc:ad1994e708194877086ebd926018ebc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the semigroup that have been enumerated so far.  <a href="#ad1994e708194877086ebd926018ebc46">More...</a><br /></td></tr>
<tr class="separator:ad1994e708194877086ebd926018ebc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b72e8a7c0b68346aa40d049ab02667b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a2b72e8a7c0b68346aa40d049ab02667b">degree</a> () const</td></tr>
<tr class="memdesc:a2b72e8a7c0b68346aa40d049ab02667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the degree of any (and all) <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>'s in the semigroup.  <a href="#a2b72e8a7c0b68346aa40d049ab02667b">More...</a><br /></td></tr>
<tr class="separator:a2b72e8a7c0b68346aa40d049ab02667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcafb10d939d027fd95817b8a1dca031"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#abcafb10d939d027fd95817b8a1dca031">elements</a> ()</td></tr>
<tr class="memdesc:abcafb10d939d027fd95817b8a1dca031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector consisting of pointers to all of the elements of the semigroup.  <a href="#abcafb10d939d027fd95817b8a1dca031">More...</a><br /></td></tr>
<tr class="separator:abcafb10d939d027fd95817b8a1dca031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f87daa414756f223752dbbc39af64a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a">enumerate</a> (std::atomic&lt; bool &gt; &amp;killed, size_t limit=<a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3">LIMIT_MAX</a>)</td></tr>
<tr class="memdesc:a06f87daa414756f223752dbbc39af64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the semigroup until <code>limit</code> elements are found or <code>killed</code> is <code>true</code>.  <a href="#a06f87daa414756f223752dbbc39af64a">More...</a><br /></td></tr>
<tr class="separator:a06f87daa414756f223752dbbc39af64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10cbfb840851c3491426345697eda3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aa10cbfb840851c3491426345697eda3f">enumerate</a> (size_t limit=<a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3">LIMIT_MAX</a>)</td></tr>
<tr class="memdesc:aa10cbfb840851c3491426345697eda3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate the semigroup until <code>limit</code> elements are found.  <a href="#aa10cbfb840851c3491426345697eda3f">More...</a><br /></td></tr>
<tr class="separator:aa10cbfb840851c3491426345697eda3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b662e18122e2fea27899c86ffc5e6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a52b662e18122e2fea27899c86ffc5e6d">factorisation</a> (<a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> &amp;word, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a52b662e18122e2fea27899c86ffc5e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes <code>word</code> in-place to contain a word in the generators equal to the <code>pos</code> element of the semigroup.  <a href="#a52b662e18122e2fea27899c86ffc5e6d">More...</a><br /></td></tr>
<tr class="separator:a52b662e18122e2fea27899c86ffc5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf40829a0714ab5497248e041f9b55e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afaf40829a0714ab5497248e041f9b55e">factorisation</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:afaf40829a0714ab5497248e041f9b55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>.  <a href="#afaf40829a0714ab5497248e041f9b55e">More...</a><br /></td></tr>
<tr class="separator:afaf40829a0714ab5497248e041f9b55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90097351d4c738f30746092276fe17a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad90097351d4c738f30746092276fe17a">factorisation</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x)</td></tr>
<tr class="memdesc:ad90097351d4c738f30746092276fe17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to.  <a href="#ad90097351d4c738f30746092276fe17a">More...</a><br /></td></tr>
<tr class="separator:ad90097351d4c738f30746092276fe17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdedc926ef14491447d5ba494befeb22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#abdedc926ef14491447d5ba494befeb22">fast_product</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> i, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> j) const</td></tr>
<tr class="memdesc:abdedc926ef14491447d5ba494befeb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code>.  <a href="#abdedc926ef14491447d5ba494befeb22">More...</a><br /></td></tr>
<tr class="separator:abdedc926ef14491447d5ba494befeb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825aab3c1591001edbb23f5de0cbfbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a825aab3c1591001edbb23f5de0cbfbb9">final_letter</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:a825aab3c1591001edbb23f5de0cbfbb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last letter of the element in position <code>pos</code>.  <a href="#a825aab3c1591001edbb23f5de0cbfbb9">More...</a><br /></td></tr>
<tr class="separator:a825aab3c1591001edbb23f5de0cbfbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da56090bdddb3760d138fb6a3dced29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a9da56090bdddb3760d138fb6a3dced29">first_letter</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:a9da56090bdddb3760d138fb6a3dced29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first letter of the element in position <code>pos</code>.  <a href="#a9da56090bdddb3760d138fb6a3dced29">More...</a><br /></td></tr>
<tr class="separator:a9da56090bdddb3760d138fb6a3dced29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b1fd15757b76f06fa86e51f3e4f159"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159">gens</a> () const</td></tr>
<tr class="memdesc:aa7b1fd15757b76f06fa86e51f3e4f159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the vector containing the generators of the semigroup.  <a href="#aa7b1fd15757b76f06fa86e51f3e4f159">More...</a><br /></td></tr>
<tr class="separator:aa7b1fd15757b76f06fa86e51f3e4f159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713836288c07d11063835f98ab317782"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a713836288c07d11063835f98ab317782">gens</a> (size_t pos) const</td></tr>
<tr class="memdesc:a713836288c07d11063835f98ab317782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the generator with index <code>pos</code>.  <a href="#a713836288c07d11063835f98ab317782">More...</a><br /></td></tr>
<tr class="separator:a713836288c07d11063835f98ab317782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70126951374ce70aee9d69a903d7fce6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a70126951374ce70aee9d69a903d7fce6">idempotents_cbegin</a> ()</td></tr>
<tr class="memdesc:a70126951374ce70aee9d69a903d7fce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator pointing at the first position of an idempotent in the semigroup.  <a href="#a70126951374ce70aee9d69a903d7fce6">More...</a><br /></td></tr>
<tr class="separator:a70126951374ce70aee9d69a903d7fce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4379278265fc1b26f220ab1805e33e0a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> &gt;::const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a4379278265fc1b26f220ab1805e33e0a">idempotents_cend</a> ()</td></tr>
<tr class="memdesc:a4379278265fc1b26f220ab1805e33e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator referring to past the end of the position of the last idempotent in the semigroup.  <a href="#a4379278265fc1b26f220ab1805e33e0a">More...</a><br /></td></tr>
<tr class="separator:a4379278265fc1b26f220ab1805e33e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a764cce3e3e7f608cd4c73f8cf855a5b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a764cce3e3e7f608cd4c73f8cf855a5b5">is_begun</a> () const</td></tr>
<tr class="memdesc:a764cce3e3e7f608cd4c73f8cf855a5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if no elements other than the generators have been enumerated so far and <code>false</code> otherwise.  <a href="#a764cce3e3e7f608cd4c73f8cf855a5b5">More...</a><br /></td></tr>
<tr class="separator:a764cce3e3e7f608cd4c73f8cf855a5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fb57b49d829b61a367f002e941f9e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae0fb57b49d829b61a367f002e941f9e1">is_done</a> () const</td></tr>
<tr class="memdesc:ae0fb57b49d829b61a367f002e941f9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the semigroup is fully enumerated and <code>false</code> if not.  <a href="#ae0fb57b49d829b61a367f002e941f9e1">More...</a><br /></td></tr>
<tr class="separator:ae0fb57b49d829b61a367f002e941f9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1880e2c3ec8574503ab1737e91691"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a75b1880e2c3ec8574503ab1737e91691">is_idempotent</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a75b1880e2c3ec8574503ab1737e91691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the element in position <code>pos</code> is an idempotent and <code>false</code> if it is not.  <a href="#a75b1880e2c3ec8574503ab1737e91691">More...</a><br /></td></tr>
<tr class="separator:a75b1880e2c3ec8574503ab1737e91691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6110cb130054d6c1844c5a3c4a8eae4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#ad4a332c5f1f30c99c8b2cddfa12423f8">cayley_graph_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a6110cb130054d6c1844c5a3c4a8eae4e">left_cayley_graph</a> ()</td></tr>
<tr class="memdesc:a6110cb130054d6c1844c5a3c4a8eae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the left Cayley graph of the semigroup.  <a href="#a6110cb130054d6c1844c5a3c4a8eae4e">More...</a><br /></td></tr>
<tr class="separator:a6110cb130054d6c1844c5a3c4a8eae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eeda3519d29dde31d365537b71339d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad9eeda3519d29dde31d365537b71339d">length_const</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:ad9eeda3519d29dde31d365537b71339d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the element in position <code>pos</code> of the semigroup.  <a href="#ad9eeda3519d29dde31d365537b71339d">More...</a><br /></td></tr>
<tr class="separator:ad9eeda3519d29dde31d365537b71339d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4b2531c73d4220872795f3c484b6a8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a1f4b2531c73d4220872795f3c484b6a8">length_non_const</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a1f4b2531c73d4220872795f3c484b6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the element in position <code>pos</code> of the semigroup.  <a href="#a1f4b2531c73d4220872795f3c484b6a8">More...</a><br /></td></tr>
<tr class="separator:a1f4b2531c73d4220872795f3c484b6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3528ae8a3bd16db58d595f0de526dc32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a3528ae8a3bd16db58d595f0de526dc32">letter_to_pos</a> (<a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a> i) const</td></tr>
<tr class="memdesc:a3528ae8a3bd16db58d595f0de526dc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the generator with index <code>i</code>.  <a href="#a3528ae8a3bd16db58d595f0de526dc32">More...</a><br /></td></tr>
<tr class="separator:a3528ae8a3bd16db58d595f0de526dc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441f1bd3ab3dc17fb3717bbe658650a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a441f1bd3ab3dc17fb3717bbe658650a8">minimal_factorisation</a> (<a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> &amp;word, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a441f1bd3ab3dc17fb3717bbe658650a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes <code>word</code> in-place to contain a minimal word with respect to the short-lex ordering in the generators equal to the <code>pos</code> element of the semigroup.  <a href="#a441f1bd3ab3dc17fb3717bbe658650a8">More...</a><br /></td></tr>
<tr class="separator:a441f1bd3ab3dc17fb3717bbe658650a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a75129d853323a81e20c807607af3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ac5a75129d853323a81e20c807607af3a">minimal_factorisation</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:ac5a75129d853323a81e20c807607af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a minimal <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>.  <a href="#ac5a75129d853323a81e20c807607af3a">More...</a><br /></td></tr>
<tr class="separator:ac5a75129d853323a81e20c807607af3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd79cb47be0f021400bf9b2e7d5bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a67cd79cb47be0f021400bf9b2e7d5bfc">minimal_factorisation</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x)</td></tr>
<tr class="memdesc:a67cd79cb47be0f021400bf9b2e7d5bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a minimal <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to <code>x</code>.  <a href="#a67cd79cb47be0f021400bf9b2e7d5bfc">More...</a><br /></td></tr>
<tr class="separator:a67cd79cb47be0f021400bf9b2e7d5bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aef49c839f223984032c0eda481bb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5">next_relation</a> (std::vector&lt; size_t &gt; &amp;relation)</td></tr>
<tr class="memdesc:ab5aef49c839f223984032c0eda481bb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method changes <code>relation</code> in-place to contain the next relation of the presentation defining <code>this</code>.  <a href="#ab5aef49c839f223984032c0eda481bb5">More...</a><br /></td></tr>
<tr class="separator:ab5aef49c839f223984032c0eda481bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdd64f5292f19094cb58b7e747d8e2a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a0bdd64f5292f19094cb58b7e747d8e2a">nrgens</a> () const</td></tr>
<tr class="memdesc:a0bdd64f5292f19094cb58b7e747d8e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of generators of the semigroup.  <a href="#a0bdd64f5292f19094cb58b7e747d8e2a">More...</a><br /></td></tr>
<tr class="separator:a0bdd64f5292f19094cb58b7e747d8e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cac1d593654e14a1fe6c9746f7eb9b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab9cac1d593654e14a1fe6c9746f7eb9b">nridempotents</a> ()</td></tr>
<tr class="memdesc:ab9cac1d593654e14a1fe6c9746f7eb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of idempotents in the semigroup.  <a href="#ab9cac1d593654e14a1fe6c9746f7eb9b">More...</a><br /></td></tr>
<tr class="separator:ab9cac1d593654e14a1fe6c9746f7eb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49234bc5f18016a360b5c124575023b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab49234bc5f18016a360b5c124575023b">nrrules</a> ()</td></tr>
<tr class="memdesc:ab49234bc5f18016a360b5c124575023b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total number of relations in the presentation defining the semigroup.  <a href="#ab49234bc5f18016a360b5c124575023b">More...</a><br /></td></tr>
<tr class="separator:ab49234bc5f18016a360b5c124575023b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fabfc3c4bd4ae5711c8097563069480"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a6fabfc3c4bd4ae5711c8097563069480">operator=</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> const &amp;semigroup)=delete</td></tr>
<tr class="memdesc:a6fabfc3c4bd4ae5711c8097563069480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted.  <a href="#a6fabfc3c4bd4ae5711c8097563069480">More...</a><br /></td></tr>
<tr class="separator:a6fabfc3c4bd4ae5711c8097563069480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3e6daf903f0a3b3fdb1181058eec69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a3a3e6daf903f0a3b3fdb1181058eec69">operator[]</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:a3a3e6daf903f0a3b3fdb1181058eec69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code>.  <a href="#a3a3e6daf903f0a3b3fdb1181058eec69">More...</a><br /></td></tr>
<tr class="separator:a3a3e6daf903f0a3b3fdb1181058eec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17f71621a3b4284c262357f07f39f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad17f71621a3b4284c262357f07f39f48">position</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x)</td></tr>
<tr class="memdesc:ad17f71621a3b4284c262357f07f39f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>x</code> in <code>this</code>, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>x</code> is not an element of <code>this</code>.  <a href="#ad17f71621a3b4284c262357f07f39f48">More...</a><br /></td></tr>
<tr class="separator:ad17f71621a3b4284c262357f07f39f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f11e32e198ccc06a9cc6522d736ba1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a4f11e32e198ccc06a9cc6522d736ba1a">position_to_sorted_position</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a4f11e32e198ccc06a9cc6522d736ba1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>this-&gt;at(pos)</code> in the sorted array of elements of the semigroup, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>pos</code> is greater than the size of the semigroup.  <a href="#a4f11e32e198ccc06a9cc6522d736ba1a">More...</a><br /></td></tr>
<tr class="separator:a4f11e32e198ccc06a9cc6522d736ba1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7540020f78f586a9ca5a4251ecc6251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#af7540020f78f586a9ca5a4251ecc6251">prefix</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:af7540020f78f586a9ca5a4251ecc6251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the prefix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>.  <a href="#af7540020f78f586a9ca5a4251ecc6251">More...</a><br /></td></tr>
<tr class="separator:af7540020f78f586a9ca5a4251ecc6251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab468d2ea4aa91f6efea4573e004d8a69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab468d2ea4aa91f6efea4573e004d8a69">product_by_reduction</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> i, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> j) const</td></tr>
<tr class="memdesc:ab468d2ea4aa91f6efea4573e004d8a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> by following a path in the Cayley graph.  <a href="#ab468d2ea4aa91f6efea4573e004d8a69">More...</a><br /></td></tr>
<tr class="separator:ab468d2ea4aa91f6efea4573e004d8a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc125204bf434124c1ca0200aec25cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a0bc125204bf434124c1ca0200aec25cf">reserve</a> (size_t n)</td></tr>
<tr class="memdesc:a0bc125204bf434124c1ca0200aec25cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Requests that the capacity (i.e. number of elements) of the semigroup be at least enough to contain n elements.  <a href="#a0bc125204bf434124c1ca0200aec25cf">More...</a><br /></td></tr>
<tr class="separator:a0bc125204bf434124c1ca0200aec25cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3debdbc4c4feb1330fcea98f8ed5951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae3debdbc4c4feb1330fcea98f8ed5951">reset_next_relation</a> ()</td></tr>
<tr class="memdesc:ae3debdbc4c4feb1330fcea98f8ed5951"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resets <a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5" title="This method changes relation in-place to contain the next relation of the presentation defining this...">Semigroup::next_relation</a> so that when it is next called the resulting relation is the first one.  <a href="#ae3debdbc4c4feb1330fcea98f8ed5951">More...</a><br /></td></tr>
<tr class="separator:ae3debdbc4c4feb1330fcea98f8ed5951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2606d7f18cb3aaf6ac796b8c3c8ba1a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibsemigroups.html#ad4a332c5f1f30c99c8b2cddfa12423f8">cayley_graph_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a2606d7f18cb3aaf6ac796b8c3c8ba1a6">right_cayley_graph</a> ()</td></tr>
<tr class="memdesc:a2606d7f18cb3aaf6ac796b8c3c8ba1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the right Cayley graph of the semigroup.  <a href="#a2606d7f18cb3aaf6ac796b8c3c8ba1a6">More...</a><br /></td></tr>
<tr class="separator:a2606d7f18cb3aaf6ac796b8c3c8ba1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4436d9a50e5b92299765e0ea1865988d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a4436d9a50e5b92299765e0ea1865988d">set_batch_size</a> (size_t <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a52a6e228af7de9d4fa627c739df0a0">batch_size</a>)</td></tr>
<tr class="memdesc:a4436d9a50e5b92299765e0ea1865988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a new value for the batch size.  <a href="#a4436d9a50e5b92299765e0ea1865988d">More...</a><br /></td></tr>
<tr class="separator:a4436d9a50e5b92299765e0ea1865988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535166da67baa70332e2da8f79488384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a535166da67baa70332e2da8f79488384">set_max_threads</a> (size_t nr_threads)</td></tr>
<tr class="memdesc:a535166da67baa70332e2da8f79488384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum number of threads that any method of an instance of <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> can use.  <a href="#a535166da67baa70332e2da8f79488384">More...</a><br /></td></tr>
<tr class="separator:a535166da67baa70332e2da8f79488384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad472ffd3e49a106d9e9c113a28b0e1aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad472ffd3e49a106d9e9c113a28b0e1aa">set_report</a> (bool val) const</td></tr>
<tr class="memdesc:ad472ffd3e49a106d9e9c113a28b0e1aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn reporting on or off.  <a href="#ad472ffd3e49a106d9e9c113a28b0e1aa">More...</a><br /></td></tr>
<tr class="separator:ad472ffd3e49a106d9e9c113a28b0e1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac383285cd9334393a068a66c7076c1d3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ac383285cd9334393a068a66c7076c1d3">size</a> ()</td></tr>
<tr class="memdesc:ac383285cd9334393a068a66c7076c1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the semigroup.  <a href="#ac383285cd9334393a068a66c7076c1d3">More...</a><br /></td></tr>
<tr class="separator:ac383285cd9334393a068a66c7076c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242842a6781cc890306c6249b1999096"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a242842a6781cc890306c6249b1999096">sorted_at</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos)</td></tr>
<tr class="memdesc:a242842a6781cc890306c6249b1999096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element of the semigroup in position <code>pos</code> of the sorted array of elements, or <code>nullptr</code> in <code>pos</code> is not valid (i.e. too big).  <a href="#a242842a6781cc890306c6249b1999096">More...</a><br /></td></tr>
<tr class="separator:a242842a6781cc890306c6249b1999096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d425c8a196e3ea46deaf2b42de4d27"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a30d425c8a196e3ea46deaf2b42de4d27">sorted_elements</a> ()</td></tr>
<tr class="memdesc:a30d425c8a196e3ea46deaf2b42de4d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector consisting of pairs <code>pair</code> where <code>pair.first</code> is a pointer to an element of the semigroup and <code>pair.second</code> is the position of that element in the semigroup. This vector is sorted according to the <a class="el" href="classlibsemigroups_1_1_element.html#afeb110ce478a2b48559dd39d840efe88" title="Returns true if this is less than that. ">Element::operator&lt;</a> method of the elements.  <a href="#a30d425c8a196e3ea46deaf2b42de4d27">More...</a><br /></td></tr>
<tr class="separator:a30d425c8a196e3ea46deaf2b42de4d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7a9a7f34a166fb6fb24908fe545fa1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#adf7a9a7f34a166fb6fb24908fe545fa1">sorted_position</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x)</td></tr>
<tr class="memdesc:adf7a9a7f34a166fb6fb24908fe545fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of <code>x</code> in the sorted array of elements of the semigroup, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>x</code> is not an element of <code>this</code>.  <a href="#adf7a9a7f34a166fb6fb24908fe545fa1">More...</a><br /></td></tr>
<tr class="separator:adf7a9a7f34a166fb6fb24908fe545fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f1effc14a755befa6212bbfacc2754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a75f1effc14a755befa6212bbfacc2754">suffix</a> (<a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> pos) const</td></tr>
<tr class="memdesc:a75f1effc14a755befa6212bbfacc2754"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position of the suffix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>.  <a href="#a75f1effc14a755befa6212bbfacc2754">More...</a><br /></td></tr>
<tr class="separator:a75f1effc14a755befa6212bbfacc2754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1667ba1b48315f4728eb1abc0e22a7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad1667ba1b48315f4728eb1abc0e22a7f">test_membership</a> (<a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *x)</td></tr>
<tr class="memdesc:ad1667ba1b48315f4728eb1abc0e22a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <code>x</code> is an element of <code>this</code> and <code>false</code> if it is not.  <a href="#ad1667ba1b48315f4728eb1abc0e22a7f">More...</a><br /></td></tr>
<tr class="separator:ad1667ba1b48315f4728eb1abc0e22a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b8731b07a29256f4e56f88258a56e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#a60b8731b07a29256f4e56f88258a56e9">word_to_element</a> (<a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> const &amp;w) const</td></tr>
<tr class="memdesc:a60b8731b07a29256f4e56f88258a56e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the element of <code>this</code> represented by the word <code>w</code>.  <a href="#a60b8731b07a29256f4e56f88258a56e9">More...</a><br /></td></tr>
<tr class="separator:a60b8731b07a29256f4e56f88258a56e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13dd8c536b6eeaa4330596112e37d68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae13dd8c536b6eeaa4330596112e37d68">word_to_pos</a> (<a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> const &amp;w) const</td></tr>
<tr class="memdesc:ae13dd8c536b6eeaa4330596112e37d68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position in the semigroup corresponding to the element represented by the word <code>w</code>.  <a href="#ae13dd8c536b6eeaa4330596112e37d68">More...</a><br /></td></tr>
<tr class="separator:ae13dd8c536b6eeaa4330596112e37d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aaf4882a1afe5a88891eb03c4fb7a0ed3"><td class="memItemLeft" align="right" valign="top">static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3">LIMIT_MAX</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:aaf4882a1afe5a88891eb03c4fb7a0ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used to indicate the maximum possible limit that can be used with <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>.  <a href="#aaf4882a1afe5a88891eb03c4fb7a0ed3">More...</a><br /></td></tr>
<tr class="separator:aaf4882a1afe5a88891eb03c4fb7a0ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac61b2bd6ef49a7659c3dca9e1f205cf"><td class="memItemLeft" align="right" valign="top">static size_t const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf">UNDEFINED</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:aac61b2bd6ef49a7659c3dca9e1f205cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup.  <a href="#aac61b2bd6ef49a7659c3dca9e1f205cf">More...</a><br /></td></tr>
<tr class="separator:aac61b2bd6ef49a7659c3dca9e1f205cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for semigroups generated by instances of <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>. </p>
<p>Semigroups are defined by a generating set, and the main method here is <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>, which implements the [Froidure-Pin Algorithm](). When the enumeration of the semigroup is complete the size, the left and right Cayley graphs are determined, and a confluent terminating presentation for the semigroup is known. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="afeab9f00f93f7f506487eb784244e20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeab9f00f93f7f506487eb784244e20e">&#9670;&nbsp;</a></span>pos_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">libsemigroups::Semigroup::pos_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type for the position of an element in an instance of <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae09471d9df3b44fbaf1b5d08c2576f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae09471d9df3b44fbaf1b5d08c2576f38">&#9670;&nbsp;</a></span>Semigroup() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::Semigroup::Semigroup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const *&#160;</td>
          <td class="paramname"><em>gens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from generators. </p>
<p>This is the default constructor for a semigroup generated by <code>gens</code>. The generators <code>gens</code> must all be of the same derived subclass of the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> base class. Additionally, <code>gens</code> must satisfy the following:</p>
<ol type="1">
<li>there must be at least one generator</li>
<li>the generators must have equal degree <a class="el" href="classlibsemigroups_1_1_element.html#a737a5e72977f33f609b0e6f63032a5f2" title="Returns the degree of an Element. ">Element::degree</a></li>
</ol>
<p>if either of these points is not satisfied, then an asssertion failure will occur.</p>
<p>There can be duplicate generators and although they do not count as distinct elements, they do count as distinct generators. In other words, the generators of the semigroup are precisely (a copy of) <code>gens</code> in the same order they occur in <code>gens</code>.</p>
<p>The generators <code>gens</code> are copied by the constructor, and so it is the responsibility of the caller to delete <code>gens</code>. </p>

</div>
</div>
<a id="adc64e868428997b22a873954262562fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc64e868428997b22a873954262562fc">&#9670;&nbsp;</a></span>Semigroup() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::Semigroup::Semigroup </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>gens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from generators. </p>
<p>See <a class="el" href="classlibsemigroups_1_1_semigroup.html#ae09471d9df3b44fbaf1b5d08c2576f38" title="Construct from generators. ">Semigroup::Semigroup</a>. </p>

</div>
</div>
<a id="aa0c7dfcba762a3ac9f0f0a58c268f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c7dfcba762a3ac9f0f0a58c268f741">&#9670;&nbsp;</a></span>Semigroup() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::Semigroup::Semigroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Constructs a new <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> which is an exact copy of <code>copy</code>. No enumeration is triggered for either <code>copy</code> or of the newly constructed semigroup. </p>

</div>
</div>
<a id="a1ad56c6cad6baba69ae4c3e1c133b428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad56c6cad6baba69ae4c3e1c133b428">&#9670;&nbsp;</a></span>~Semigroup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libsemigroups::Semigroup::~Semigroup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a8af8615e4a45aa6e83837f01baa5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8af8615e4a45aa6e83837f01baa5a2">&#9670;&nbsp;</a></span>add_generators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::add_generators </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the generators <code>coll</code> to the generators of <code>this</code>. </p>
<p>This method can be used to add new generators to the existing semigroup in such a way that any previously enumerated data is preserved and not recomputed, or copied. This can be faster than recomputing the semigroup generated by the old generators and the new generators in the parameter <code>coll</code>.</p>
<p>This method changes the semigroup in-place, thereby invalidating possibly previously known data about the semigroup, such as the left or right Cayley graphs, number of idempotents, and so on.</p>
<p>Every generator in <code>coll</code> is added regardless of whether or not it is already a generator or element of the semigroup (it may belong to the semigroup but just not be known to belong). If <code>coll</code> is empty, then the semigroup is left unchanged. The order the generators is added is also the order they occur in the parameter <code>coll</code>.</p>
<p>The semigroup is returned in a state where all of the previously enumerated elements which had been multiplied by all of the old generators, have now been multiplied by all of the old and new generators. This means that after this method is called the semigroup might contain many more elements than before (whether it is fully enumerating or not). It can also be the case that the new generators are the only new elements, unlike, say, in the case of non-trivial groups.</p>
<p>The elements the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. </p>

</div>
</div>
<a id="ad58bf0d461a907ccf7ee6f124c97a7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58bf0d461a907ccf7ee6f124c97a7a6">&#9670;&nbsp;</a></span>add_generators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::add_generators </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the generators <code>coll</code> to the generators of <code>this</code>. </p>
<p>See <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2" title="Add copies of the generators coll to the generators of this. ">Semigroup::add_generators</a> for more details. </p>

</div>
</div>
<a id="ad6215251257f940170f43f4f403d998d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6215251257f940170f43f4f403d998d">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> * libsemigroups::Semigroup::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code>, or a <code>nullptr</code> if there is no such element. </p>
<p>This method attempts to enumerate the semigroup until at least <code>pos</code> + 1 elements have been found. If <code>pos</code> is greater than <a class="el" href="classlibsemigroups_1_1_semigroup.html#ac383285cd9334393a068a66c7076c1d3" title="Returns the size of the semigroup. ">Semigroup::size</a>, then this method returns <code>nullptr</code>. </p>

</div>
</div>
<a id="a7a52a6e228af7de9d4fa627c739df0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a52a6e228af7de9d4fa627c739df0a0">&#9670;&nbsp;</a></span>batch_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::batch_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current value of the batch size. This is the minimum number of elements enumerated in any call to <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>. </p>

</div>
</div>
<a id="a6820e18dfb877db3a868463335d8ea65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6820e18dfb877db3a868463335d8ea65">&#9670;&nbsp;</a></span>closure() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::closure </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>. </p>
<p>This method can be used to add new generators to an existing semigroup in such a way that any previously enumerated data is preserved and not recomputed, or copied. This can be faster than recomputing the semigroup generated by the old generators and the new in <code>coll</code>.</p>
<p>This method differs from <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2" title="Add copies of the generators coll to the generators of this. ">Semigroup::add_generators</a> in that it tries to add the new generators one by one, and only adds those generators that are not products of existing generators (including any new generators from <code>coll</code> that were added before). The generators are added in the order they occur in <code>coll</code>.</p>
<p>This method changes the semigroup in-place, thereby invalidating possibly previously known data about the semigroup, such as the left or right Cayley graphs, or number of idempotents, for example.</p>
<p>The elements the parameter <code>coll</code> are copied into the semigroup, and should be deleted by the caller. </p>

</div>
</div>
<a id="a726b4e24b52fbbf56b934d785361a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726b4e24b52fbbf56b934d785361a842">&#9670;&nbsp;</a></span>closure() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::closure </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const &amp;&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add copies of the non-redundant generators in <code>coll</code> to the generators of <code>this</code>. </p>
<p>See <a class="el" href="classlibsemigroups_1_1_semigroup.html#a6820e18dfb877db3a868463335d8ea65" title="Add copies of the non-redundant generators in coll to the generators of this. ">Semigroup::closure</a> for more details. </p>

</div>
</div>
<a id="aa3218fc2409ab38bf5c4360967df70b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3218fc2409ab38bf5c4360967df70b2">&#9670;&nbsp;</a></span>copy_add_generators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> * libsemigroups::Semigroup::copy_add_generators </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; *&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new semigroup generated by <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">gens()</a></code> and <code>coll</code>. </p>
<p>This method is equivalent to copying <code>this</code> using <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa0c7dfcba762a3ac9f0f0a58c268f741" title="Copy constructor. ">Semigroup::Semigroup(const Semigroup&amp; copy)</a> and then calling <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2" title="Add copies of the generators coll to the generators of this. ">Semigroup::add_generators</a> on the copy, but this method avoids copying the parts of <code>this</code> that are immediately invalidated by <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2" title="Add copies of the generators coll to the generators of this. ">Semigroup::add_generators</a>.</p>
<p>The elements the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. </p>

</div>
</div>
<a id="a0e06fb2f4c02e76bfe3148ad57a5257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e06fb2f4c02e76bfe3148ad57a5257f">&#9670;&nbsp;</a></span>copy_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> * libsemigroups::Semigroup::copy_closure </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&gt; const *&#160;</td>
          <td class="paramname"><em>coll</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new semigroup generated by <code>this-&gt;<a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">gens()</a></code> and copies of the non-redundant elements of <code>coll</code>. </p>
<p>This method is equivalent to copying <code>this</code> and then calling <a class="el" href="classlibsemigroups_1_1_semigroup.html#a6820e18dfb877db3a868463335d8ea65" title="Add copies of the non-redundant generators in coll to the generators of this. ">Semigroup::closure</a> on the copy with <code>coll</code>, but this method avoids copying the parts of <code>this</code> that are immediately invalidated by <a class="el" href="classlibsemigroups_1_1_semigroup.html#a6820e18dfb877db3a868463335d8ea65" title="Add copies of the non-redundant generators in coll to the generators of this. ">Semigroup::closure</a>.</p>
<p>The elements the argument <code>coll</code> are copied into the semigroup, and should be deleted by the caller. </p>

</div>
</div>
<a id="ae27b64c78b82236c611c8b82018d6243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27b64c78b82236c611c8b82018d6243">&#9670;&nbsp;</a></span>current_max_word_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::current_max_word_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum length of a word in the generators so far computed. </p>
<p>Every elements of the semigroup can be expressed as a product of the generators. The elements of the semigroup are enumerated in the short-lex order induced by the order of the generators (as passed to <a class="el" href="classlibsemigroups_1_1_semigroup.html#ae09471d9df3b44fbaf1b5d08c2576f38" title="Construct from generators. ">Semigroup::Semigroup</a>). This method returns the length of the longest word in the generators that has so far been enumerated. </p>

</div>
</div>
<a id="a9254472e2374d27a915bd533103c8da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9254472e2374d27a915bd533103c8da0">&#9670;&nbsp;</a></span>current_nrrules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::current_nrrules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of relations in the presentation for the semigroup that have been found so far. </p>
<p>This is only the actual number of relations in a presentation defining the semigroup if the semigroup is fully enumerated. </p>

</div>
</div>
<a id="a63553b44a18e9fb8fe7329e953938f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63553b44a18e9fb8fe7329e953938f10">&#9670;&nbsp;</a></span>current_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> libsemigroups::Semigroup::current_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup. </p>
<p>This method finds the position of the element <code>x</code> in the semigroup if it is already known to belong to the semigroup, and <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">libsemigroups::Semigroup::UNDEFINED</a> if not. If the semigroup is not fully enumerated, then this method may return <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">libsemigroups::Semigroup::UNDEFINED</a> when <code>x</code> is in the semigroup, but not this is not yet known.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_semigroup.html#ad17f71621a3b4284c262357f07f39f48" title="Returns the position of x in this, or Semigroup::UNDEFINED if x is not an element of this...">Semigroup::position</a> and <a class="el" href="classlibsemigroups_1_1_semigroup.html#adf7a9a7f34a166fb6fb24908fe545fa1" title="Returns the position of x in the sorted array of elements of the semigroup, or Semigroup::UNDEFINED i...">Semigroup::sorted_position</a>. FIXME these should be <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> const* </dd></dl>

</div>
</div>
<a id="ad1994e708194877086ebd926018ebc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1994e708194877086ebd926018ebc46">&#9670;&nbsp;</a></span>current_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::current_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the semigroup that have been enumerated so far. </p>
<p>This is only the actual size of the semigroup if the semigroup is fully enumerated. </p>

</div>
</div>
<a id="a2b72e8a7c0b68346aa40d049ab02667b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b72e8a7c0b68346aa40d049ab02667b">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the degree of any (and all) <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a>'s in the semigroup. </p>

</div>
</div>
<a id="abcafb10d939d027fd95817b8a1dca031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcafb10d939d027fd95817b8a1dca031">&#9670;&nbsp;</a></span>elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlibsemigroups_1_1_element.html">Element</a>*&gt;* libsemigroups::Semigroup::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the vector consisting of pointers to all of the elements of the semigroup. </p>

</div>
</div>
<a id="a06f87daa414756f223752dbbc39af64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f87daa414756f223752dbbc39af64a">&#9670;&nbsp;</a></span>enumerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::enumerate </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>killed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3">LIMIT_MAX</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate the semigroup until <code>limit</code> elements are found or <code>killed</code> is <code>true</code>. </p>
<p>This is the main method of the <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> class, where the Froidure-Pin Algorithm is implemented.</p>
<p>If the semigroup is already fully enumerated, or the number of elements previously enumerated exceeds <code>limit</code>, then calling this method does nothing. Otherwise, enumerate attempts to find at least the maximum of <code>limit</code> and <a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a52a6e228af7de9d4fa627c739df0a0" title="Returns the current value of the batch size. This is the minimum number of elements enumerated in any...">Semigroup::batch_size</a> elements of the semigroup. If <code>killed</code> is set to <code>true</code> (usually by another process), then the enumeration is terminated as soon as possible. It is possible to resume enumeration at some later point after any call to this method, even if it has been killed.</p>
<p>If the semigroup is fully enumerated, then it knows its left and right Cayley graphs, and a minimal factorisation of every element (in terms of its generating set). All of the elements are stored in memory until the object is destroyed.</p>
<p>The parameter <code>limit</code> defaults to <a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3" title="This variable is used to indicate the maximum possible limit that can be used with Semigroup::enumera...">Semigroup::LIMIT_MAX</a>. </p>

</div>
</div>
<a id="aa10cbfb840851c3491426345697eda3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10cbfb840851c3491426345697eda3f">&#9670;&nbsp;</a></span>enumerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::enumerate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classlibsemigroups_1_1_semigroup.html#aaf4882a1afe5a88891eb03c4fb7a0ed3">LIMIT_MAX</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumerate the semigroup until <code>limit</code> elements are found. </p>
<p>See <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate(std::atomic&lt;bool&gt;&amp; killed, size_t limit)</a> for more details. </p>

</div>
</div>
<a id="a52b662e18122e2fea27899c86ffc5e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b662e18122e2fea27899c86ffc5e6d">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes <code>word</code> in-place to contain a word in the generators equal to the <code>pos</code> element of the semigroup. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_semigroup.html#a441f1bd3ab3dc17fb3717bbe658650a8" title="Changes word in-place to contain a minimal word with respect to the short-lex ordering in the generat...">Semigroup::minimal_factorisation(word_t&amp; word, pos_t pos)</a>, is that the resulting factorisation may not be minimal. </p>

</div>
</div>
<a id="afaf40829a0714ab5497248e041f9b55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf40829a0714ab5497248e041f9b55e">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a>* libsemigroups::Semigroup::factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_semigroup.html#ac5a75129d853323a81e20c807607af3a" title="Returns a pointer to a minimal libsemigroups::word_t which evaluates to the Element in position pos o...">Semigroup::minimal_factorisation(pos_t pos)</a>, is that the resulting factorisation may not be minimal. </p>

</div>
</div>
<a id="ad90097351d4c738f30746092276fe17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90097351d4c738f30746092276fe17a">&#9670;&nbsp;</a></span>factorisation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> * libsemigroups::Semigroup::factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to. </p>
<p>The key difference between this method and <a class="el" href="classlibsemigroups_1_1_semigroup.html#a67cd79cb47be0f021400bf9b2e7d5bfc" title="Returns a pointer to a minimal libsemigroups::word_t which evaluates to x. ">Semigroup::minimal_factorisation(Element* x)</a>, is that the resulting factorisation may not be minimal. </p>

</div>
</div>
<a id="abdedc926ef14491447d5ba494befeb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdedc926ef14491447d5ba494befeb22">&#9670;&nbsp;</a></span>fast_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> libsemigroups::Semigroup::fast_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code>. </p>
<p>This method asserts that the parameters <code>i</code> and <code>j</code> are less than <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad1994e708194877086ebd926018ebc46" title="Returns the number of elements in the semigroup that have been enumerated so far. ...">Semigroup::current_size</a>, and it either:</p>
<ul>
<li>follows the path in the right or left Cayley graph from <code>i</code> to <code>j</code>, whichever is shorter using <a class="el" href="classlibsemigroups_1_1_semigroup.html#ab468d2ea4aa91f6efea4573e004d8a69" title="Returns the position in this of the product of this-&gt;at(i) and this-&gt;at(j) by following a path in the...">Semigroup::product_by_reduction</a>; or</li>
<li>multiplies the elements in postions <code>i</code> and <code>j</code> together;</li>
</ul>
<p>whichever is better. The method used is determined by comparing <a class="el" href="classlibsemigroups_1_1_element.html#ac7d80fabf8c999e505980ec0cf64a55a" title="Returns the approximate time complexity of multiplying two Elements in a given subclass. ">Element::complexity</a> and the <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad9eeda3519d29dde31d365537b71339d" title="Returns the length of the element in position pos of the semigroup. ">Semigroup::length_const</a> of <code>i</code> and <code>j</code>.</p>
<p>For example, if the <a class="el" href="classlibsemigroups_1_1_element.html#ac7d80fabf8c999e505980ec0cf64a55a" title="Returns the approximate time complexity of multiplying two Elements in a given subclass. ">Element::complexity</a> of the multiplication is linear and <code>this</code> is a semigroup of transformations of degree 20, and the shortest paths in the left and right Cayley graphs from <code>i</code> to <code>j</code> are of length 100 and 1131, then it better to just multiply the transformations together. </p>

</div>
</div>
<a id="a825aab3c1591001edbb23f5de0cbfbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825aab3c1591001edbb23f5de0cbfbb9">&#9670;&nbsp;</a></span>final_letter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a> libsemigroups::Semigroup::final_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last letter of the element in position <code>pos</code>. </p>
<p>This method returns the final letter of the element in position <code>pos</code> of the semigroup, which is the index of the generator corresponding to the first letter of the element.</p>
<p>Note that <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>[<a class="el" href="classlibsemigroups_1_1_semigroup.html#a825aab3c1591001edbb23f5de0cbfbb9" title="Returns the last letter of the element in position pos. ">Semigroup::final_letter</a>(<code>pos</code>)] is only equal to <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad6215251257f940170f43f4f403d998d" title="Returns the element of the semigroup in position pos, or a nullptr if there is no such element...">Semigroup::at</a>(<a class="el" href="classlibsemigroups_1_1_semigroup.html#a825aab3c1591001edbb23f5de0cbfbb9" title="Returns the last letter of the element in position pos. ">Semigroup::final_letter</a>(<code>pos</code>)) if there are no duplicate generators.</p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, this is asserted in the method. </p>

</div>
</div>
<a id="a9da56090bdddb3760d138fb6a3dced29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da56090bdddb3760d138fb6a3dced29">&#9670;&nbsp;</a></span>first_letter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a> libsemigroups::Semigroup::first_letter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first letter of the element in position <code>pos</code>. </p>
<p>This method returns the first letter of the element in position <code>pos</code> of the semigroup, which is the index of the generator corresponding to the first letter of the element.</p>
<p>Note that <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>[<a class="el" href="classlibsemigroups_1_1_semigroup.html#a9da56090bdddb3760d138fb6a3dced29" title="Returns the first letter of the element in position pos. ">Semigroup::first_letter</a>(<code>pos</code>)] is only equal to <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad6215251257f940170f43f4f403d998d" title="Returns the element of the semigroup in position pos, or a nullptr if there is no such element...">Semigroup::at</a>(<a class="el" href="classlibsemigroups_1_1_semigroup.html#a9da56090bdddb3760d138fb6a3dced29" title="Returns the first letter of the element in position pos. ">Semigroup::first_letter</a>(<code>pos</code>)) if there are no duplicate generators.</p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, this is asserted in the method. </p>

</div>
</div>
<a id="aa7b1fd15757b76f06fa86e51f3e4f159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b1fd15757b76f06fa86e51f3e4f159">&#9670;&nbsp;</a></span>gens() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classlibsemigroups_1_1_element.html">Element</a>*&gt;* libsemigroups::Semigroup::gens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the vector containing the generators of the semigroup. </p>

</div>
</div>
<a id="a713836288c07d11063835f98ab317782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713836288c07d11063835f98ab317782">&#9670;&nbsp;</a></span>gens() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a>* libsemigroups::Semigroup::gens </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the generator with index <code>pos</code>. </p>

</div>
</div>
<a id="a70126951374ce70aee9d69a903d7fce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70126951374ce70aee9d69a903d7fce6">&#9670;&nbsp;</a></span>idempotents_cbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> &gt;::const_iterator libsemigroups::Semigroup::idempotents_cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator pointing at the first position of an idempotent in the semigroup. </p>
<p>If the returned iterator is incremented, then it points to the second position of an idempotent in the semigroup (if it exists), and every subsequent increment points to the next position of an idempotent.</p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="a4379278265fc1b26f220ab1805e33e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4379278265fc1b26f220ab1805e33e0a">&#9670;&nbsp;</a></span>idempotents_cend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> &gt;::const_iterator libsemigroups::Semigroup::idempotents_cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator referring to past the end of the position of the last idempotent in the semigroup. </p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="a764cce3e3e7f608cd4c73f8cf855a5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a764cce3e3e7f608cd4c73f8cf855a5b5">&#9670;&nbsp;</a></span>is_begun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libsemigroups::Semigroup::is_begun </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if no elements other than the generators have been enumerated so far and <code>false</code> otherwise. </p>

</div>
</div>
<a id="ae0fb57b49d829b61a367f002e941f9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fb57b49d829b61a367f002e941f9e1">&#9670;&nbsp;</a></span>is_done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libsemigroups::Semigroup::is_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the semigroup is fully enumerated and <code>false</code> if not. </p>
<p>The semigroup is fully enumerated when the product of every element by every generator is known. </p>

</div>
</div>
<a id="a75b1880e2c3ec8574503ab1737e91691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1880e2c3ec8574503ab1737e91691">&#9670;&nbsp;</a></span>is_idempotent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool libsemigroups::Semigroup::is_idempotent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the element in position <code>pos</code> is an idempotent and <code>false</code> if it is not. </p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. </p>

</div>
</div>
<a id="a6110cb130054d6c1844c5a3c4a8eae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6110cb130054d6c1844c5a3c4a8eae4e">&#9670;&nbsp;</a></span>left_cayley_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#ad4a332c5f1f30c99c8b2cddfa12423f8">cayley_graph_t</a>* libsemigroups::Semigroup::left_cayley_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the left Cayley graph of the semigroup. </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="ad9eeda3519d29dde31d365537b71339d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eeda3519d29dde31d365537b71339d">&#9670;&nbsp;</a></span>length_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::length_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the element in position <code>pos</code> of the semigroup. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, this is asserted in the method. This method causes no enumeration of the semigroup. </p>

</div>
</div>
<a id="a1f4b2531c73d4220872795f3c484b6a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4b2531c73d4220872795f3c484b6a8">&#9670;&nbsp;</a></span>length_non_const()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::length_non_const </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of the element in position <code>pos</code> of the semigroup. </p>
<p>The parameter <code>pos</code> must be a valid position of an element of the semigroup, this is asserted in the method. </p>

</div>
</div>
<a id="a3528ae8a3bd16db58d595f0de526dc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3528ae8a3bd16db58d595f0de526dc32">&#9670;&nbsp;</a></span>letter_to_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> libsemigroups::Semigroup::letter_to_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2">letter_t</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the generator with index <code>i</code>. </p>
<p>This method asserts that the value of <code>i</code> is valid. In many cases <code>letter_to_pos(i)</code> will equal <code>i</code>, examples of when this will not be the case are:</p>
<ul>
<li>there are duplicate generators;</li>
<li><a class="el" href="classlibsemigroups_1_1_semigroup.html#a7a8af8615e4a45aa6e83837f01baa5a2" title="Add copies of the generators coll to the generators of this. ">Semigroup::add_generators</a> was called after the semigroup was already partially enumerated. </li>
</ul>

</div>
</div>
<a id="a441f1bd3ab3dc17fb3717bbe658650a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441f1bd3ab3dc17fb3717bbe658650a8">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> &amp;&#160;</td>
          <td class="paramname"><em>word</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes <code>word</code> in-place to contain a minimal word with respect to the short-lex ordering in the generators equal to the <code>pos</code> element of the semigroup. </p>
<p>If <code>pos</code> is less than the size of this semigroup, then this method changes its first parameter <code>word</code> in-place by first clearing it and then to contain a minimal factorization of the element in position <code>pos</code> of the semigroup with respect to the generators of the semigroup. This method enumerates the semigroup until at least the <code>pos</code> element is known. If <code>pos</code> is greater than the size of the semigroup, then nothing happens and word is not modified, in particular not cleared. </p>

</div>
</div>
<a id="ac5a75129d853323a81e20c807607af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a75129d853323a81e20c807607af3a">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> * libsemigroups::Semigroup::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a minimal <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to the <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> in position <code>pos</code> of <code>this</code>. </p>
<p>This is the same as the two-argument method for <a class="el" href="classlibsemigroups_1_1_semigroup.html#a441f1bd3ab3dc17fb3717bbe658650a8" title="Changes word in-place to contain a minimal word with respect to the short-lex ordering in the generat...">Semigroup::minimal_factorisation</a>, but it returns a pointer to the factorisation instead of modifying an argument in-place. </p>

</div>
</div>
<a id="a67cd79cb47be0f021400bf9b2e7d5bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cd79cb47be0f021400bf9b2e7d5bfc">&#9670;&nbsp;</a></span>minimal_factorisation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> * libsemigroups::Semigroup::minimal_factorisation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a minimal <a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6" title="Type for a word over the generators of a semigroup. ">libsemigroups::word_t</a> which evaluates to <code>x</code>. </p>
<p>This is the same as the method taking a <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e" title="Type for the position of an element in an instance of Semigroup. ">Semigroup::pos_t</a>, but it factorises an <a class="el" href="classlibsemigroups_1_1_element.html" title="Abstract base class for semigroup elements. ">Element</a> instead of using the position of an element. </p>

</div>
</div>
<a id="ab5aef49c839f223984032c0eda481bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5aef49c839f223984032c0eda481bb5">&#9670;&nbsp;</a></span>next_relation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::next_relation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>relation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method changes <code>relation</code> in-place to contain the next relation of the presentation defining <code>this</code>. </p>
<p>This method changes <code>relation</code> in-place so that one of the following holds:</p>
<ul>
<li><code>relation</code> is a vector consisting of a <a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_t</a> and a <a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_t</a> such that <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>(<code>relation</code>[<code>0</code>]) == <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>(<code>relation</code>[<code>1</code>]), i.e. if the semigroup was defined with duplicate generators;</li>
<li><code>relation</code> is a vector consisting of a libsemigroups::pos_t, <a class="el" href="namespacelibsemigroups.html#a38c2911ca7f82f35322c4b82e3c671e2" title="Type for the index of a generator of a semigroup. ">libsemigroups::letter_t</a>, and libsemigroups::pos_t such that <div class="fragment"><div class="line"><span class="keyword">this</span>[relation[0]] * <a class="code" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159">Semigroup::gens</a>(relation[1]) == <span class="keyword">this</span>[relation[2]]</div></div><!-- fragment --></li>
<li><code>relation</code> is empty if there are no more relations.</li>
</ul>
<p><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5" title="This method changes relation in-place to contain the next relation of the presentation defining this...">Semigroup::next_relation</a> is guaranteed to output all relations of length 2 before any relations of length 3. If called repeatedly after <a class="el" href="classlibsemigroups_1_1_semigroup.html#ae3debdbc4c4feb1330fcea98f8ed5951" title="This method resets Semigroup::next_relation so that when it is next called the resulting relation is ...">Semigroup::reset_next_relation</a>, and until relation is empty, the values placed in <code>relation</code> correspond to a length-reducing confluent rewriting system that defines the semigroup.</p>
<p>This method can be used in conjunction with <a class="el" href="classlibsemigroups_1_1_semigroup.html#a52b662e18122e2fea27899c86ffc5e6d" title="Changes word in-place to contain a word in the generators equal to the pos element of the semigroup...">Semigroup::factorisation</a> to obtain a presentation defining the semigroup.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae3debdbc4c4feb1330fcea98f8ed5951" title="This method resets Semigroup::next_relation so that when it is next called the resulting relation is ...">Semigroup::reset_next_relation</a>. </dd></dl>

</div>
</div>
<a id="a0bdd64f5292f19094cb58b7e747d8e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bdd64f5292f19094cb58b7e747d8e2a">&#9670;&nbsp;</a></span>nrgens()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::nrgens </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of generators of the semigroup. </p>

</div>
</div>
<a id="ab9cac1d593654e14a1fe6c9746f7eb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cac1d593654e14a1fe6c9746f7eb9b">&#9670;&nbsp;</a></span>nridempotents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::nridempotents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the total number of idempotents in the semigroup. </p>
<p>This method involves fully enumerating the semigroup, if it is not already fully enumerated. The value of the positions, and number, of idempotents is stored after they are first computed. </p>

</div>
</div>
<a id="ab49234bc5f18016a360b5c124575023b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49234bc5f18016a360b5c124575023b">&#9670;&nbsp;</a></span>nrrules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::nrrules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the total number of relations in the presentation defining the semigroup. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5" title="This method changes relation in-place to contain the next relation of the presentation defining this...">Semigroup::next_relation</a>. </dd></dl>

</div>
</div>
<a id="a6fabfc3c4bd4ae5711c8097563069480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fabfc3c4bd4ae5711c8097563069480">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a>&amp; libsemigroups::Semigroup::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html">Semigroup</a> const &amp;&#160;</td>
          <td class="paramname"><em>semigroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deleted. </p>
<p>The <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> class does not support an assignment contructor to avoid accidental copying. An object in <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> may use many gigabytes of memory and might be extremely expensive to copy. A copy constructor is provided in case such a copy should it be required anyway. </p>

</div>
</div>
<a id="a3a3e6daf903f0a3b3fdb1181058eec69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3e6daf903f0a3b3fdb1181058eec69">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a>* libsemigroups::Semigroup::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code>. </p>
<p>This method performs no checks on its argument, and performs no enumeration of the semigroup. </p>

</div>
</div>
<a id="ad17f71621a3b4284c262357f07f39f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17f71621a3b4284c262357f07f39f48">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> libsemigroups::Semigroup::position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of <code>x</code> in <code>this</code>, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>x</code> is not an element of <code>this</code>. </p>
<p>This method can be used to find the <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e" title="Type for the position of an element in an instance of Semigroup. ">Semigroup::pos_t</a> position of the element <code>x</code> if it belongs to the semigroup. The semigroup is enumerated in batches until <code>x</code> is found or the semigroup is fully enumerated but <code>x</code> was not found (see <a class="el" href="classlibsemigroups_1_1_semigroup.html#a4436d9a50e5b92299765e0ea1865988d" title="Set a new value for the batch size. ">Semigroup::set_batch_size</a>). </p>

</div>
</div>
<a id="a4f11e32e198ccc06a9cc6522d736ba1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f11e32e198ccc06a9cc6522d736ba1a">&#9670;&nbsp;</a></span>position_to_sorted_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::position_to_sorted_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of <code>this-&gt;at(pos)</code> in the sorted array of elements of the semigroup, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>pos</code> is greater than the size of the semigroup. </p>

</div>
</div>
<a id="af7540020f78f586a9ca5a4251ecc6251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7540020f78f586a9ca5a4251ecc6251">&#9670;&nbsp;</a></span>prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> libsemigroups::Semigroup::prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the prefix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, this is asserted in the method. </p>

</div>
</div>
<a id="ab468d2ea4aa91f6efea4573e004d8a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab468d2ea4aa91f6efea4573e004d8a69">&#9670;&nbsp;</a></span>product_by_reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> libsemigroups::Semigroup::product_by_reduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position in <code>this</code> of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> by following a path in the Cayley graph. </p>
<p>This method asserts that the values <code>i</code> and <code>j</code> are valid, in that they are less than <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad1994e708194877086ebd926018ebc46" title="Returns the number of elements in the semigroup that have been enumerated so far. ...">Semigroup::current_size</a>. This method returns the position <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e" title="Type for the position of an element in an instance of Semigroup. ">Semigroup::pos_t</a> in the semigroup of the product of <code>this-&gt;at(i)</code> and <code>this-&gt;at(j)</code> elements by following the path in the right or left Cayley graph from <code>i</code> to <code>j</code>, whichever is shorter. </p>

</div>
</div>
<a id="a0bc125204bf434124c1ca0200aec25cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc125204bf434124c1ca0200aec25cf">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Requests that the capacity (i.e. number of elements) of the semigroup be at least enough to contain n elements. </p>
<p>The parameter <code>n</code> is also used to initialise certain data members, if you know a good upper bound for the size of your semigroup, then it is a good idea to call this method with that upper bound as an argument, this can significantly improve the performance of the <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a> method, and consequently every other method too. </p>

</div>
</div>
<a id="ae3debdbc4c4feb1330fcea98f8ed5951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3debdbc4c4feb1330fcea98f8ed5951">&#9670;&nbsp;</a></span>reset_next_relation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::reset_next_relation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method resets <a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5" title="This method changes relation in-place to contain the next relation of the presentation defining this...">Semigroup::next_relation</a> so that when it is next called the resulting relation is the first one. </p>
<p>After a call to this function, the next call to <a class="el" href="classlibsemigroups_1_1_semigroup.html#ab5aef49c839f223984032c0eda481bb5" title="This method changes relation in-place to contain the next relation of the presentation defining this...">Semigroup::next_relation</a> will return the first relation of the presentation defining the semigroup. </p>

</div>
</div>
<a id="a2606d7f18cb3aaf6ac796b8c3c8ba1a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2606d7f18cb3aaf6ac796b8c3c8ba1a6">&#9670;&nbsp;</a></span>right_cayley_graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibsemigroups.html#ad4a332c5f1f30c99c8b2cddfa12423f8">cayley_graph_t</a>* libsemigroups::Semigroup::right_cayley_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the right Cayley graph of the semigroup. </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="a4436d9a50e5b92299765e0ea1865988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4436d9a50e5b92299765e0ea1865988d">&#9670;&nbsp;</a></span>set_batch_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::set_batch_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a new value for the batch size. </p>
<p>The <em>batch size</em> is the number of new elements to be found by any call to <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>. A call to enumerate returns between 0 and approximately the batch size.</p>
<p>The default value of the batch size is 8192.</p>
<p>This is used by, for example, <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad17f71621a3b4284c262357f07f39f48" title="Returns the position of x in this, or Semigroup::UNDEFINED if x is not an element of this...">Semigroup::position</a> so that it is possible to find the position of an element without fully enumerating the semigroup. </p>

</div>
</div>
<a id="a535166da67baa70332e2da8f79488384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a535166da67baa70332e2da8f79488384">&#9670;&nbsp;</a></span>set_max_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::set_max_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nr_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum number of threads that any method of an instance of <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> can use. </p>
<p>This method sets the maximum number of threads to be used by any method of a <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> object. The number of threads is limited to the maximum of 1 and the minimum of <code>nr_threads</code> and the number of threads supported by the hardware. </p>

</div>
</div>
<a id="ad472ffd3e49a106d9e9c113a28b0e1aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad472ffd3e49a106d9e9c113a28b0e1aa">&#9670;&nbsp;</a></span>set_report()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libsemigroups::Semigroup::set_report </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turn reporting on or off. </p>
<p>If <code>val</code> is true, then some methods for a <a class="el" href="classlibsemigroups_1_1_semigroup.html" title="Class for semigroups generated by instances of Element. ">Semigroup</a> object may report information about the progress of the computation. </p>

</div>
</div>
<a id="ac383285cd9334393a068a66c7076c1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac383285cd9334393a068a66c7076c1d3">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the semigroup. </p>

</div>
</div>
<a id="a242842a6781cc890306c6249b1999096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242842a6781cc890306c6249b1999096">&#9670;&nbsp;</a></span>sorted_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> * libsemigroups::Semigroup::sorted_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the element of the semigroup in position <code>pos</code> of the sorted array of elements, or <code>nullptr</code> in <code>pos</code> is not valid (i.e. too big). </p>
<p>This method fully enumerates the semigroup. </p>

</div>
</div>
<a id="a30d425c8a196e3ea46deaf2b42de4d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d425c8a196e3ea46deaf2b42de4d27">&#9670;&nbsp;</a></span>sorted_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="classlibsemigroups_1_1_element.html">Element</a>*, <a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&gt; &gt;* libsemigroups::Semigroup::sorted_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector consisting of pairs <code>pair</code> where <code>pair.first</code> is a pointer to an element of the semigroup and <code>pair.second</code> is the position of that element in the semigroup. This vector is sorted according to the <a class="el" href="classlibsemigroups_1_1_element.html#afeb110ce478a2b48559dd39d840efe88" title="Returns true if this is less than that. ">Element::operator&lt;</a> method of the elements. </p>

</div>
</div>
<a id="adf7a9a7f34a166fb6fb24908fe545fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf7a9a7f34a166fb6fb24908fe545fa1">&#9670;&nbsp;</a></span>sorted_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t libsemigroups::Semigroup::sorted_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position of <code>x</code> in the sorted array of elements of the semigroup, or <a class="el" href="classlibsemigroups_1_1_semigroup.html#aac61b2bd6ef49a7659c3dca9e1f205cf" title="This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. ">Semigroup::UNDEFINED</a> if <code>x</code> is not an element of <code>this</code>. </p>

</div>
</div>
<a id="a75f1effc14a755befa6212bbfacc2754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f1effc14a755befa6212bbfacc2754">&#9670;&nbsp;</a></span>suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a> libsemigroups::Semigroup::suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the position of the suffix of the element <code>x</code> in position <code>pos</code> (of the semigroup) of length one less than the length of <code>x</code>. </p>
<p>The parameter <code>pos</code> must be a valid position of an already enumerated element of the semigroup, this is asserted in the method. </p>

</div>
</div>
<a id="ad1667ba1b48315f4728eb1abc0e22a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1667ba1b48315f4728eb1abc0e22a7f">&#9670;&nbsp;</a></span>test_membership()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool libsemigroups::Semigroup::test_membership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if <code>x</code> is an element of <code>this</code> and <code>false</code> if it is not. </p>
<p>This method can be used to check if the element <code>x</code> is an element of the semigroup. The semigroup is enumerated in batches until <code>x</code> is found or the semigroup is fully enumerated but <code>x</code> was not found (see <a class="el" href="classlibsemigroups_1_1_semigroup.html#a4436d9a50e5b92299765e0ea1865988d" title="Set a new value for the batch size. ">Semigroup::set_batch_size</a>). </p>

</div>
</div>
<a id="a60b8731b07a29256f4e56f88258a56e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b8731b07a29256f4e56f88258a56e9">&#9670;&nbsp;</a></span>word_to_element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_element.html">Element</a> * libsemigroups::Semigroup::word_to_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the element of <code>this</code> represented by the word <code>w</code>. </p>
<p>The parameter <code>w</code> must consist of non-negative integers less than <a class="el" href="classlibsemigroups_1_1_semigroup.html#a0bdd64f5292f19094cb58b7e747d8e2a" title="Returns the number of generators of the semigroup. ">Semigroup::nrgens</a>. This method returns a pointer to the element of <code>this</code> obtained by evaluating <code>w</code>. This is equivalent to finding the product <code>x</code> of the generators <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>(<code>w</code>[i]).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_semigroup.html#ae13dd8c536b6eeaa4330596112e37d68" title="Returns the position in the semigroup corresponding to the element represented by the word w...">Semigroup::word_to_pos</a>. </dd></dl>

</div>
</div>
<a id="ae13dd8c536b6eeaa4330596112e37d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13dd8c536b6eeaa4330596112e37d68">&#9670;&nbsp;</a></span>word_to_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> libsemigroups::Semigroup::word_to_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacelibsemigroups.html#a70af4e1758957fcdbd183fffda4e78c6">word_t</a> const &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the position in the semigroup corresponding to the element represented by the word <code>w</code>. </p>
<p>The parameter <code>w</code> must consist of non-negative integers less than <a class="el" href="classlibsemigroups_1_1_semigroup.html#a0bdd64f5292f19094cb58b7e747d8e2a" title="Returns the number of generators of the semigroup. ">Semigroup::nrgens</a>. This method returns the position in <code>this</code> of the element obtained by evaluating <code>w</code>. This is equivalent to finding the product <code>x</code> of the generators <a class="el" href="classlibsemigroups_1_1_semigroup.html#aa7b1fd15757b76f06fa86e51f3e4f159" title="Returns a pointer to the vector containing the generators of the semigroup. ">Semigroup::gens</a>(<code>w</code>[i]) and then calling <a class="el" href="classlibsemigroups_1_1_semigroup.html#ad17f71621a3b4284c262357f07f39f48" title="Returns the position of x in this, or Semigroup::UNDEFINED if x is not an element of this...">Semigroup::position</a> with argument <code>x</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classlibsemigroups_1_1_semigroup.html#a60b8731b07a29256f4e56f88258a56e9" title="Returns a pointer to the element of this represented by the word w. ">Semigroup::word_to_element</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaf4882a1afe5a88891eb03c4fb7a0ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf4882a1afe5a88891eb03c4fb7a0ed3">&#9670;&nbsp;</a></span>LIMIT_MAX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> const libsemigroups::Semigroup::LIMIT_MAX = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variable is used to indicate the maximum possible limit that can be used with <a class="el" href="classlibsemigroups_1_1_semigroup.html#a06f87daa414756f223752dbbc39af64a" title="Enumerate the semigroup until limit elements are found or killed is true. ">Semigroup::enumerate</a>. </p>

</div>
</div>
<a id="aac61b2bd6ef49a7659c3dca9e1f205cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac61b2bd6ef49a7659c3dca9e1f205cf">&#9670;&nbsp;</a></span>UNDEFINED</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibsemigroups_1_1_semigroup.html#afeab9f00f93f7f506487eb784244e20e">Semigroup::pos_t</a> const libsemigroups::Semigroup::UNDEFINED = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This variable is used to indicate that a value is undefined, such as, for example, the position of an element that does not belong to a semigroup. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="semigroups_8h_source.html">semigroups.h</a></li>
<li>src/semigroups.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Aug 23 2017 15:55:18 for libsemigroups by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
